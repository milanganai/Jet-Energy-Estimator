//----------------------------------------------------------------------
/// \file
/// \page Example07 07 - subtracting jet background contamination
///
/// fastjet subtraction example program. 
///
/// run it with    : ./07-subtraction < data/Pythia-Zp2jets-lhc-pileup-1ev.dat
///
/// Source code: 07-subtraction.cc
//----------------------------------------------------------------------

//STARTHEADER
// $Id: 07-subtraction.cc 3670 2014-09-08 14:17:59Z soyez $
//
// Copyright (c) 2005-2011, Matteo Cacciari, Gavin P. Salam and Gregory Soyez
//
//----------------------------------------------------------------------
// This file is part of FastJet.
//
//  FastJet is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  The algorithms that underlie FastJet have required considerable
//  development and are described in hep-ph/0512210. If you use
//  FastJet as part of work towards a scientific publication, please
//  include a citation to the FastJet paper.
//
//  FastJet is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with FastJet. If not, see <http://www.gnu.org/licenses/>.
//----------------------------------------------------------------------
//ENDHEADER

#include "fastjet/PseudoJet.hh"
#include "fastjet/ClusterSequenceArea.hh"
#include "fastjet/Selector.hh"
#include "fastjet/tools/JetMedianBackgroundEstimator.hh"
#include "fastjet/tools/Subtractor.hh" 
#include <iostream> // needed for io
#include <fstream> // needed for io
#include <fastjet/config.h>  // for the FASTJET_VERSION_NUMBER preprocessor symbol

using namespace std;
using namespace fastjet;



class nopu_info {
   public:
   int nopu_id; //id of the nopu jet
   int pu_id; //map id to pu jet with maximum  sharing
   PseudoJet shared_pt; //sum of pt of shared constituents
};

class particle_info {
   public:
   bool is_neutral;
   bool is_pu;
   string name;
};

vector<nopu_info> nopu_info_vec;
vector<particle_info> particle_info_vec;
double R = 0.4; //
int csv_flag = 1; //0: readable, 1: csv
int append_flag = 1; //0: over-write, 1: append 
string fin_name;
string fout_name;

PseudoJet get_shared_pt(const vector<PseudoJet> &c1, const vector<PseudoJet> &c2)
{
   PseudoJet pt;
   for (unsigned int k = 0; k < c1.size(); k++) {
      for (unsigned int j = 0; j < c2.size(); j++) {
           if (have_same_momentum(c1[k],c2[j])) pt += c1[k];
      }
   }
   return pt;
}

void find_matching(vector<PseudoJet> &nopu_jets, vector<PseudoJet> & pu_jets)
{
   vector<bool> taken(pu_jets.size());
   for (unsigned int k = 0; k < nopu_jets.size(); k++) {
      int max_j = -1;
      PseudoJet max_pt;
      for (unsigned int j = 0; j < pu_jets.size(); j++) {
          if (taken[j]) continue;
          PseudoJet pt = get_shared_pt(nopu_jets[k].constituents(), pu_jets[j].constituents());
          if (max_pt.pt() < pt.pt()) { max_pt = pt; max_j = j; }
      }
      if (max_j != -1) taken[max_j] = true;
      nopu_info_vec[k].nopu_id = k;
      nopu_info_vec[k].pu_id = max_j;
      nopu_info_vec[k].shared_pt = max_pt ;
   }

}

PseudoJet sum_pt(vector<PseudoJet> c, bool is_neutral, bool is_pu)
{
   PseudoJet p;
   for (unsigned int k = 0; k < c.size(); k++) {
      int id  = c[k].user_index();
      if (particle_info_vec[id].is_neutral == is_neutral  && 
         particle_info_vec[id].is_pu == is_pu) {
         p += c[k];
      }
   }
   return p;
}


int generate_jet();


int main() 
{
   string line;

   while (getline(cin, line)) {
     istringstream linestream(line);
     if (line.substr(0,1) == "#") {continue;}
     if (line.substr(0,3) == "EOF") {break;}
     linestream >> R >> fin_name >> append_flag >> csv_flag >> fout_name;
     generate_jet();
   }
   return 0;

}

int generate_jet(){
  
  // read in input particles
  //
  // since we use here simulated data we can split the hard event
  // from the full (i.e. with pileup added) one
  //----------------------------------------------------------

  vector<PseudoJet> hard_event, full_event;
  
  // read in input particles. Keep the hard event generated by PYTHIA
  // separated from the full event, so as to be able to gauge the
  // "goodness" of the subtraction from the full event, which also
  // includes pileup
  double particle_maxrap = 5.0;

  nopu_info_vec.clear();
  particle_info_vec.clear();

  string line;
  int  nsub  = 0; // counter to keep track of which sub-event we're reading

  ifstream inFile;
  inFile.open(fin_name.c_str());

  while (getline(inFile, line)) {
    istringstream linestream(line);
    // take substrings to avoid problems when there are extra "pollution"
    // characters (e.g. line-feed).
    if (line.substr(0,4) == "#END") {break;}
    if (line.substr(0,9) == "#SUBSTART") {
      // if more sub events follow, make copy of first one (the hard one) here
      if (nsub == 1) hard_event = full_event;
      nsub += 1;
    }
    if (line.substr(0,1) == "#") {continue;}
    double px,py,pz,E;
    char neutral_tag; //neutral_tag = ('n' or 'c')
    char pu_tag; //pu_tag = ('p' or 'h')
    string name;
    linestream >> name >> neutral_tag >> pu_tag >> px >> py >> pz >> E;
    // you can construct 
    PseudoJet particle(px,py,pz,E);


    // push event onto back of full_event vector
    if (abs(particle.rap()) <= particle_maxrap) {
      particle.set_user_index(full_event.size());
      particle_info pi;
      pi.is_neutral = (neutral_tag == 'n');
      pi.is_pu = (pu_tag == 'p');
      pi.name = name;
      particle_info_vec.push_back(pi);
      full_event.push_back(particle);
    }
  }

  // if we have read in only one event, copy it across here...
  if (nsub == 1) hard_event = full_event;



  // if there was nothing in the event 
  if (nsub == 0) {
    cerr << "Error: read empty event\n";
    exit(-1);
  }
  cout << "nsub = " << nsub << endl;
  
  
  // create a jet definition for the clustering
  // We use the anti-kt algorithm with a radius of 0.5
  //----------------------------------------------------------
  JetDefinition jet_def(antikt_algorithm, R);

  // create an area definition for the clustering
  //----------------------------------------------------------
  // ghosts should go up to the acceptance of the detector or
  // (with infinite acceptance) at least 2R beyond the region
  // where you plan to investigate jets.
  double ghost_maxrap = 6.0;
  GhostedAreaSpec area_spec(ghost_maxrap);
  AreaDefinition area_def(active_area, area_spec);

  // run the jet clustering with the above jet and area definitions
  // for both the hard and full event
  //
  // We retrieve the jets above 7 GeV in both case (note that the
  // 7-GeV cut we be applied again later on after we subtract the jets
  // from the full event)
  // ----------------------------------------------------------
  ClusterSequenceArea clust_seq_hard(hard_event, jet_def, area_def);
  ClusterSequenceArea clust_seq_full(full_event, jet_def, area_def);

  double ptmin = 7.0;
  vector<PseudoJet> hard_jets = sorted_by_pt(clust_seq_hard.inclusive_jets(ptmin));
  vector<PseudoJet> full_jets = sorted_by_pt(clust_seq_full.inclusive_jets(ptmin));

  // Now turn to the estimation of the background (for the full event)
  //
  // There are different ways to do that. In general, this also
  // requires clustering the particles that will be handled internally
  // in FastJet. 
  //
  // The suggested way to proceed is to use a BackgroundEstimator
  // constructed from the following 3 arguments:
  //  - a jet definition used to cluster the particles.
  //    . We strongly recommend using the kt or Cambridge/Aachen
  //      algorithm (a warning will be issued otherwise)
  //    . The choice of the radius is a bit more subtle. R=0.4 has
  //      been chosen to limit the impact of hard jets; in samples of
  //      dominantly sparse events it may cause the UE/pileup to be
  //      underestimated a little, a slightly larger value (0.5 or
  //      0.6) may be better.
  //  - An area definition for which we recommend the use of explicit
  //    ghosts (i.e. active_area_explicit_ghosts)
  //    As mentionned in the area example (06-area.cc), ghosts should
  //    extend sufficiently far in rapidity to cover the jets used in
  //    the computation of the background (see also the comment below)
  //  - A Selector specifying the range over which we will keep the
  //    jets entering the estimation of the background (you should
  //    thus make sure the ghosts extend far enough in rapidity to
  //    cover the range, a warning will be issued otherwise).
  //    In this particular example, the two hardest jets in the event
  //    are removed from the background estimation
  // ----------------------------------------------------------
  JetDefinition jet_def_bkgd(kt_algorithm, 0.4);
  AreaDefinition area_def_bkgd(active_area_explicit_ghosts, 
			       GhostedAreaSpec(ghost_maxrap));
  //Selector selector = SelectorAbsRapMax(4.5) * (!SelectorNHardest(2));
  Selector selector = SelectorAbsRapMax(4.5);
  JetMedianBackgroundEstimator bkgd_estimator(selector, jet_def_bkgd, area_def_bkgd);

  // To help manipulate the background estimator, we also provide a
  // transformer that allows to apply directly the background
  // subtraction on the jets. This will use the background estimator
  // to compute rho for the jets to be subtracted.
  // ----------------------------------------------------------
  Subtractor subtractor(&bkgd_estimator);
  
  // since FastJet 3.1.0, rho_m is supported natively in background
  // estimation (both JetMedianBackgroundEstimator and
  // GridMedianBackgroundEstimator).
  //
  // For backward-compatibility reasons its use is by default switched off
  // (as is the enforcement of m>0 for the subtracted jets). The
  // following 2 lines of code switch these on. They are strongly
  // recommended and should become the default in future versions of
  // FastJet.
  //
  // Note that we also illustrate the use of the
  // FASTJET_VERSION_NUMBER macro
#if FASTJET_VERSION_NUMBER >= 30100
  subtractor.set_use_rho_m(true);
  subtractor.set_safe_mass(true);
#endif

  // Finally, once we have an event, we can just tell the background
  // estimator to use that list of particles
  // This could be done directly when declaring the background
  // estimator but the usage below can more easily be accomodated to a
  // loop over a set of events.
  // ----------------------------------------------------------
  bkgd_estimator.set_particles(full_event);

  // show a summary of what was done so far
  //  - the description of the algorithms, areas and ranges used
  //  - the background properties
  //  - the jets in the hard event
  //----------------------------------------------------------
#if DBG
  cout << "Main clustering:" << endl;
  cout << "  Ran:   " << jet_def.description() << endl;
  cout << "  Area:  " << area_def.description() << endl;
  cout << "  Particles up to |y|=" << particle_maxrap << endl;
  cout << endl;

  cout << "Background estimation:" << endl;
  cout << "  " << bkgd_estimator.description() << endl << endl;;
  cout << "  Giving, for the full event" << endl;
  cout << "    rho     = " << bkgd_estimator.rho()   << endl;
  cout << "    sigma   = " << bkgd_estimator.sigma() << endl; 
#if FASTJET_VERSION_NUMBER >= 30100
  cout << "    rho_m   = " << bkgd_estimator.rho_m()   << endl;
  cout << "    sigma_m = " << bkgd_estimator.sigma_m() << endl; 
#endif
  cout << "    mean_area = " << bkgd_estimator.mean_area() << endl; 
  cout << "    n_jets_used = " << bkgd_estimator.n_jets_used() << endl; 
  cout << "    empty_area = " << bkgd_estimator.empty_area() << endl; 
  cout << "    n_empty_jets = " << bkgd_estimator.n_empty_jets() << endl; 
  cout << endl;

  cout << "Jets above " << ptmin << " GeV in the hard event (" << hard_event.size() << " particles)" << endl;
  cout << "---------------------------------------\n";
  printf("%5s %15s %15s %15s %15s %15s\n","jet #", "rapidity", "phi", "pt", "m", "area");
   for (unsigned int i = 0; i < hard_jets.size(); i++) {
    printf("%5u %15.8f %15.8f %15.8f %15.8f %15.8f\n", i,
	   hard_jets[i].rap(), hard_jets[i].phi(), hard_jets[i].pt(), hard_jets[i].m(),
	   hard_jets[i].area());
  }
  cout << endl;

  // Once the background properties have been computed, subtraction
  // can be applied on the jets. Subtraction is performed on the
  // full 4-vector
  //
  // We output the jets before and after subtraction
  // ----------------------------------------------------------
  cout << "Jets above " << ptmin << " GeV in the full event (" << full_event.size() << " particles)" << endl;
  cout << "---------------------------------------\n";
  printf("%5s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s\n","jet #", "rapidity", "phi", "pt", "m", "area", "rap_sub", "phi_sub", "pt_sub", "m_sub", "pt_area");
  unsigned int idx=0;
#endif

  // get the subtracted jets
  vector<PseudoJet> subtracted_jets = subtractor(full_jets);

#if DBG

  for (unsigned int i=0; i<full_jets.size(); i++){
    // re-apply the pt cut
    if (subtracted_jets[i].pt2() >= ptmin*ptmin){
      char c = full_jets[i].is_pure_ghost() ? ' ' : '*';
      printf("%c%5u %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f\n", c,idx,
	     full_jets[i].rap(), full_jets[i].phi(), full_jets[i].pt(), full_jets[i].m(),
	     full_jets[i].area(),
	     subtracted_jets[i].rap(), subtracted_jets[i].phi(), 
	     subtracted_jets[i].pt(), 
	     subtracted_jets[i].m(), full_jets[i].pt()/full_jets[i].area());
      idx++;
    }
  }
#endif
  nopu_info_vec.resize(hard_jets.size());
  find_matching(hard_jets,full_jets);
#if DBG
  printf("hj,fj,hj_pt,fj_pt,sub_fj_pt,shared_pt, fj_cpv_pt,fj_cpu_pt,shared_pt\n");
  for (unsigned int i=0; i<nopu_info_vec.size(); i++){
     int hj = nopu_info_vec[i].nopu_id;
     int fj = nopu_info_vec[i].pu_id;
     if (fj == -1) continue;
     printf("%d,%d,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f\n",
             hj,fj,hard_jets[hj].pt(),full_jets[fj].pt(),subtracted_jets[fj].pt(),
            nopu_info_vec[i].shared_pt.pt(),
            sum_pt(full_jets[fj].constituents(),false,false).pt(),
            sum_pt(full_jets[fj].constituents(),false,true).pt());
        
  }
#endif
  FILE *fout = fopen(fout_name.c_str(),(append_flag)?"a":"w");
  
  char *format_nocsv = "%15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f %15.8f\n";
  char *format_csv = "%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f,%15.8f\n";
  char *header = "%15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s %15s\n";
  char *format;
  if (csv_flag) {
    if (!append_flag)
      fprintf(fout,"jpt_hard,jpt_hard_m,sub_hard,sub_hard_m,jpt_full,jpt_full_m,sum_pv,sum_pu,eta,phi,area,rho,sigma,rho_m,sigma_m,R,n_pv,n_pu\n");
    format = format_csv;
  }else {
    if (!append_flag)
      fprintf(fout,header,"jpt_hard","jpt_hard_m","sub_hard","sub_hard_m","jpt_full","jpt_full_m","sum_pv","sum_pu","eta","phi","area","rho","sigma","rho_m","sigma_m","R","n_pv","n_pu");
    format = format_nocsv;
  }
  for (unsigned int i=0; i<nopu_info_vec.size(); i++){
     int hj = nopu_info_vec[i].nopu_id;
     int fj = nopu_info_vec[i].pu_id;
     if (fj == -1) continue;
     fprintf(fout,format,
            hard_jets[hj].pt(),
            hard_jets[hj].m(),
            subtracted_jets[fj].pt(),
            subtracted_jets[fj].m(),
            full_jets[fj].pt(),
            full_jets[fj].m(),
            sum_pt(full_jets[fj].constituents(),false,false).pt(),
            sum_pt(full_jets[fj].constituents(),false,true).pt(),
            full_jets[fj].rap(),
            full_jets[fj].phi(),
            full_jets[fj].area(),
            bkgd_estimator.rho(),
            bkgd_estimator.sigma(),
            bkgd_estimator.rho_m(),
            bkgd_estimator.sigma_m(),
            R,
            (float) hard_event.size(),
            (float)full_event.size()-hard_event.size());
  }
  fclose(fout);

  return 0;
}
